node {
  # Type of cryptography
  waves-crypto = yes

  # Node owner address
  owner-address = " /FILL/ " 

  # NTP settings
  ntp.fatal-timeout = 5 minutes

  # Node "home" and data directories to store the state
  directory = "/node"
  data-directory = "/node/data"

  wallet {
    # Path to keystore.
    file = "/node/keystore.dat"

    # Access password
    password = " /FILL/ "
  }

  # Blockchain settings
  blockchain {
    type = CUSTOM
    fees.enabled = false
    consensus {
      type = "poa"
      round-duration = "17s"
      sync-duration = "3s"
      ban-duration-blocks = 100
      warnings-for-ban = 3
      max-bans-percentage = 40
    }
    custom {
      address-scheme-character = "E"
      functionality {
        feature-check-blocks-period = 1500
        blocks-for-feature-activation = 1000
        pre-activated-features = { 2 = 0, 3 = 0, 4 = 0, 5 = 0, 6 = 0, 7 = 0, 9 = 0, 10 = 0, 100 = 0, 101 = 0 }
      }

      # Mainnet genesis settings
      genesis {
        average-block-delay: 60s
        initial-base-target: 153722867

        # Filled by GenesisBlockGenerator
        block-timestamp: 1573472578702

        initial-balance: 1625000000000000

        # Filled by GenesisBlockGenerator
        genesis-public-key-base-58: ""

        # Filled by GenesisBlockGenerator
        signature: ""

        transactions = [
            # Initial token distribution:
            # - recipient: target's blockchain address (base58 string)
            # - amount: amount of tokens, multiplied by 10e8 (integer)
            #
            #     Example: { recipient: "3HQSr3VFCiE6JcWwV1yX8xttYbAGKTLV3Gz", amount: 3000000000000000 }
            #
            # Note:
            #   Sum of amounts must be equal to initial-balance above.
            #
          { recipient: " /FILL/ ", amount: 100000000000000 },
          { recipient: " /FILL/ ", amount: 150000000000000 },
          { recipient: " /FILL/ ", amount: 50000000000000 },
        ]
        network-participants = [
            # Initial participants and role distribution
            # - public-key: participant's base58 encoded public key;
            # - roles: list of roles to be granted;
            #
            #     Example: {public-key: "EPxkVA9iQejsjQikovyxkkY8iHnbXsR3wjgkgE7ZW1Tt", roles: [permissioner, miner, connection_manager, contract_developer, issuer]}
            #
            # Note:
            #   There has to be at least one miner, one permissioner and one connection_manager for the network to start correctly.
            #   Participants are granted access to the network via GenesisRegisterNodeTransaction.
            #   Role list could be empty, then given public-key will only be granted access to the network.
            #
          { public-key: " /FILL/ ", roles: [permissioner, miner, connection_manager, contract_developer, issuer]},
          { public-key: " /FILL/ ", roles: [miner]},
          { public-key: " /FILL/ ", roles: []},
        ]
      }
    }
  }

  # Application logging level. Could be DEBUG | INFO | WARN | ERROR. Default value is INFO.
  logging-level = DEBUG

  # P2P Network settings
  network {
    # Network address
    bind-address = "0.0.0.0"
    # Port number
    port = 6864

    # Peers network addresses and ports
    #   Example: known-peers = ["node-1.com:6864", "node-2.com:6864"]
    known-peers = [  /FILL/  ]

    # Node name to send during handshake. Comment this string out to set random node name.
    #   Example: node-name = "your-we-node-name"
    node-name = " /FILL/ "

    # How long the information about peer stays in database after the last communication with it
    peers-data-residence-time = 2h

    # String with IP address and port to send as external address during handshake. Could be set automatically if uPnP is enabled.
    #   Example: declared-address = "your-node-address.com:6864"
    declared-address = "0.0.0.0:6864"
  }

  # New blocks generator settings
  miner {
    enable = yes
    # Important: use quorum = 0 only for testing purposes, while running a single-node network;
    # In other cases always set quorum > 0
    quorum = 0
    interval-after-last-block-then-generation-is-allowed = 10d
    micro-block-interval = 5s
    min-micro-block-age = 3s
    max-transactions-in-micro-block = 500
    minimal-block-generation-offset = 200ms
  }

  # Nodes REST API settings
  rest-api {
    # Enable/disable REST API
    enable = yes

    # Network address to bind to
    bind-address = "0.0.0.0"

    # Port to listen to REST API requests
    port = 6862

    auth {
      type: "api-key"

      # Hash of API key string
      # You can obtain hashes by running ApiKeyHash generator
      api-key-hash: " /FILL/ "

      # Hash of API key string for PrivacyApi routes
      privacy-api-key-hash: " /FILL/ "
    }
  }

  #Settings for Privacy Data Exchange
  privacy {
    storage {
      enabled = false
      # url = "jdbc:postgresql://postgres:5432/node-1?user=postgres&password=wenterprise"
      # driver = "org.postgresql.Driver"
      # profile = "slick.jdbc.PostgresProfile$"

      # user = "postgres@postgres&password=wenterprise"
      # password = "wenterprise"

      # connectionPool = HikariCP
      # connectionTimeout = 5000
      # connectionTestQuery = "SELECT 1"
      # queueSize = 10000
      # numThreads = 20
      # schema = "public"
      # migration-dir = "db/migration"
    }
  }

  
  # Docker smart contracts settings
  docker-engine {
    # Docker smart contracts enabled flag
    enable = yes
    integration-tests-mode-enable = yes
    # Basic auth credentials for docker host
     #docker-auth {
     #  username = "some user"
     #  password = "some password"
     #}

    # Optional connection string to docker host
     docker-host = "unix:///var/run/docker.sock"

    # Optional string to node REST API if we use remote docker host
    # node-rest-api = "node-0"

    # Execution settings
    execution-limits {
      # Contract execution timeout
      timeout = 10s
      # Memory limit in Megabytes
      memory = 512
      # Memory swap value in Megabytes (see https://docs.docker.com/config/containers/resource_constraints/)
      memory-swap = 0
    }

    # Reuse once created container on subsequent executions
    reuse-containers = yes

    # Remove container with contract after specified duration passed
    remove-container-after = 10m

    # Allows net access for all contracts
    allow-net-access = yes

    # Remote registries auth information
    remote-registries = []

    # Check registry auth on node startup
    check-registry-auth-on-startup = yes

    # Contract execution messages cache settings
    contract-execution-messages-cache {
      # Time to expire for messages in cache
      expire-after = 60m
      # Max number of messages in buffer. When the limit is reached, the node processes all messages in batch
      max-buffer-size = 10
      # Max time for buffer. When time is out, the node processes all messages in batch
      max-buffer-time = 100ms
    }
  }
}

