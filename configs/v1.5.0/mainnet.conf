node {
  synchronization {
    extension-batch-size = 100
  }
  # Type of cryptography
  waves-crypto = yes

  # Node owner address
  owner-address = " /FILL/ "

  # Waves "home" and data directories to store the state
  directory = "/node"
  data-directory = ${node.directory}"/data"

  # Location and name of a license file
  # license.file = ${node.directory}"/node.license"

  wallet {
    # Path to keystore file
    file = "/node/keystore.dat"
    
    # Access password
    password = " /FILL/ "
  }

  # Blockchain settings
  # Mainnet blockchain settings (should match on all nodes for consistency)
  blockchain.type = MAINNET

  # Application logging level. Could be DEBUG | INFO | WARN | ERROR. Default value is INFO.
  logging-level = DEBUG

  tls {
    # Supported TLS types:
    # • EMBEDDED: Certificate is signed by node's provider and packed into JKS Keystore. The same file is used as a Truststore.
    #             Has to be manually imported into system by user to avoid certificate warnings.
    # • DISABLED: TLS is fully disabled
    type = DISABLED

    # type = EMBEDDED
    # keystore-path = ${node.directory}"/we_tls.jks"
    # keystore-password = ${TLS_KEYSTORE_PASSWORD}
    # private-key-password = ${TLS_PRIVATE_KEY_PASSWORD}
  }

  # P2P Network settings
  network {
    # Network address
    bind-address = "0.0.0.0"

    # Port number
    port = 6864

    # Enable/disable network TLS
    tls = no

    # Peers network addresses and ports
    known-peers = ["node-0.wavesenterprise.com:6864", "node-1.wavesenterprise.com:6864", "node-2.wavesenterprise.com:6864"]
    # Node name to send during handshake. Comment this string out to set random node name.
    #   Example: node-name = "your-we-node-name"
    node-name = " /FILL/ "

    # How long the information about peer stays in database after the last communication with it
    peers-data-residence-time = 2h

    # Breaks a connection if there is no message from the peer during this timeout
    break-idle-connections-timeout = 3m

    # String with IP address and port to send as external address during handshake. Could be set automatically if uPnP is enabled.
    declared-address = "0.0.0.0:6864"
  }

  # Node's REST API settings
  api {
    rest {
      enable = yes
      bind-address = "0.0.0.0"
      port = 6862
      tls = no
    }

    grpc {
      enable = yes
      bind-address = "0.0.0.0"
      port = 6865
      tls = no

      akka-http-settings {
        akka {
          http.server.idle-timeout = infinite
        }
      }
    }

    auth {
      # Available types: api-key or oauth2. The second one requires installing OAuth2 service. Please, refer to the docs for info.
      type: "api-key"

      # Hashed secret Api-Key to access node's REST API
      api-key-hash = " /FILL/ "

      # Api-key hash for Privacy Data Exchange REST API methods
      privacy-api-key-hash = " /FILL/ "
    }
  }

  # New blocks generator settings
  miner {
    enable = yes
    quorum = 2
    interval-after-last-block-then-generation-is-allowed = 35d
    micro-block-interval = 5s
    min-micro-block-age = 3s
    max-transactions-in-micro-block = 500
    minimal-block-generation-offset = 200ms
  }

  # Settings for Privacy Data Exchange
  privacy {

    # Max parallel data crawling tasks
    crawling-parallelism = 100
  
    # DB connection config
    storage {
      # Possible values: s3, postgres or none
      vendor = none

      # for s3 vendor:
      # url = "http://localhost:9000/"
      # bucket = "privacy"
      # region = "aws-global"
      # access-key-id = "minio"
      # secret-access-key = "minio123"
      # path-style-access-enabled = true
      # connection-timeout = 30s
      # connection-acquisition-timeout = 10s
      # max-concurrency = 200
      # read-timeout = 0s

      # for postgres vendor:
      # schema = "public"
      # migration-dir = "db/migration"
      # profile = "slick.jdbc.PostgresProfile$"
      # jdbc-config {
      #   url = "jdbc:postgresql://"${POSTGRES_ADDRESS}":"${POSTGRES_PORT}"/"${POSTGRES_DB}
      #   driver = "org.postgresql.Driver"
      #   user = ${POSTGRES_USER}
      #   password = ${POSTGRES_PASSWORD}
      #   connectionPool = HikariCP
      #   connectionTimeout = 5000
      #   connectionTestQuery = "SELECT 1"
      #   queueSize = 10000
      #   numThreads = 20
      # }
    }

    # Periodically deletes files that have not been added to the blockchain
    cleaner {
      enabled: no

      # The amount of time between cleanups
      # interval: 10m

      # How many blocks the data hash transaction exists on the blockchain, after which it will be removed from cleaner monitoring
      # confirmation-blocks: 100

      # The maximum amount of time that a file can be stored without getting into the blockchain
      # pending-time: 72h
    }
  }

  # Docker smart-contracts engine config
  docker-engine {
    # Docker smart contracts enabled flag
    enable = yes

    # For starting contracts in a local docker
    use-node-docker-host = yes

    default-registry-domain = "registry.wavesenterprise.com/waves-enterprise-public"

    # Basic auth credentials for docker host
     #docker-auth {
     #  username = "some user"
     #  password = "some password"
     #}

    # Optional connection string to docker host
     docker-host = "unix:///var/run/docker.sock"

    # Optional string to node REST API if we use remote docker host
    # node-rest-api = "node-0"

    # Execution settings
    execution-limits {
      # Contract execution timeout
      timeout = 30s
      # Memory limit in Megabytes
      memory = 512
      # Memory swap value in Megabytes (see https://docs.docker.com/config/containers/resource_constraints/)
      memory-swap = 0
    }

    # Reuse once created container on subsequent executions
    reuse-containers = yes

    # Remove container with contract after specified duration passed
    remove-container-after = 10m

    # Remote registries auth information
    remote-registries = []

    # Check registry auth on node startup
    check-registry-auth-on-startup = yes

    # Contract execution messages cache settings
    contract-execution-messages-cache {
      # Time to expire for messages in cache
      expire-after = 60m
      # Max number of messages in buffer. When the limit is reached, the node processes all messages in batch
      max-buffer-size = 10
      # Max time for buffer. When time is out, the node processes all messages in batch
      max-buffer-time = 100ms
    }
  }
}